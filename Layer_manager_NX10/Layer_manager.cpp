//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  C:\Users\jie\Documents\Example\application\Layer_manager.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: jie
//              Version: NX 10
//              Date: 06-14-2016  (Format: mm-dd-yyyy)
//              Time: 20:24 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "Layer_manager.hpp"

using namespace NXOpen;
using namespace NXOpen::BlockStyler;

//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(Layer_manager::theSession) = NULL;
UI *(Layer_manager::theUI) = NULL;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
Layer_manager::Layer_manager()
{
    try
    {
        // Initialize the NX Open C++ API environment
        Layer_manager::theSession = NXOpen::Session::GetSession();
        Layer_manager::theUI = UI::GetUI();

		TCHAR path[MAX_PATH];
		char path_name[250];
		char dlx_name[250];
		GetModuleFileName(GetModuleHandle(TEXT("Layer_sort.dll")),path,MAX_PATH);
		TcharToChar(path,path_name);
		vector<string> splite_string;
		string temp = path_name;
		Splite(temp, ".", splite_string);
		strcpy(dlx_name, splite_string[0].c_str());
		strcat(dlx_name, ".dlx");

        theDlxFileName = dlx_name;
        theDialog = Layer_manager::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        theDialog->AddApplyHandler(make_callback(this, &Layer_manager::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &Layer_manager::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &Layer_manager::update_cb));
        theDialog->AddInitializeHandler(make_callback(this, &Layer_manager::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &Layer_manager::dialogShown_cb));
        theDialog->AddEnableOKButtonHandler(make_callback(this, &Layer_manager::enableOKButton_cb));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
Layer_manager::~Layer_manager()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
}
//------------------------------- DIALOG LAUNCHING ---------------------------------
//
//    Before invoking this application one needs to open any part/empty part in NX
//    because of the behavior of the blocks.
//
//    Make sure the dlx file is in one of the following locations:
//        1.) From where NX session is launched
//        2.) $UGII_USER_DIR/application
//        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//            recommended. This variable is set to a full directory path to a file 
//            containing a list of root directories for all custom applications.
//            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
//
//    You can create the dialog using one of the following way:
//
//    1. MENU BAR
//    
//        1) Add the following lines to your MenuScript file in order to
//           associate a menu bar button with your dialog.  In this
//           example, a cascade menu will be created and will be
//           located just before the Help button on the main menubar.
//           The button, SAMPLEVB_BTN is set up to launch your dialog and
//           will be positioned as the first button on your pulldown menu.
//           If you wish to add the button to an existing cascade, simply
//           add the 3 lines between MENU LAUNCH_CASCADE and END_OF_MENU
//           to your menuscript file.
//           The MenuScript file requires an extension of ".men".
//           Move the contents between the dashed lines to your Menuscript file.
//        
//           !-----------------------------------------------------------------------------
//           VERSION 120
//        
//           EDIT UG_GATEWAY_MAIN_MENUBAR
//        
//           BEFORE UG_HELP
//           CASCADE_BUTTON BLOCKSTYLER_DLX_CASCADE_BTN
//           LABEL Dialog Launcher
//           END_OF_BEFORE
//        
//           MENU BLOCKSTYLER_DLX_CASCADE_BTN
//           BUTTON SAMPLEVB_BTN
//           LABEL Display SampleVB dialog
//           ACTIONS <path of Shared library> !For example: D:\temp\SampleVB.dll
//           END_OF_MENU
//           !-----------------------------------------------------------------------------
//        
//        2) Make sure the .men file is in one of the following locations:
//        
//           - $UGII_USER_DIR/startup   
//           - For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//             recommended. This variable is set to a full directory path to a file 
//             containing a list of root directories for all custom applications.
//             e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_ROOT_DIR\menus\custom_dirs.dat
//    
//------------------------------------------------------------------------------
extern "C" DllExport void  ufusr(char *param, int *retcod, int param_len)
{
    Layer_manager *theLayer_manager = NULL;
    try
    {
        theLayer_manager = new Layer_manager();
        // The following method shows the dialog immediately
        theLayer_manager->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    if(theLayer_manager != NULL)
    {
        delete theLayer_manager;
        theLayer_manager = NULL;
    }
}

int Layer_manager::Show()
{
    try
    {
        theDialog->Show();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void Layer_manager::initialize_cb()
{
    try
    {
        group0 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group0"));
        button0 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button0"));
        button01 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button01"));
		classification_done = false;
	}
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void Layer_manager::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
int Layer_manager::apply_cb()
{
    int errorCode = 0;
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int Layer_manager::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
        UF_initialize();
		//Create the layer category
		if(block == button0)
        {
			if(!classification_done)
			{
				UF_LAYER_category_info_s info;
				tag_t category;
				logical layer_mask[UF_LAYER_MAX_LAYER];

				memset(layer_mask, 0, sizeof(layer_mask));
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));

				//Change the default layer of Solid Body
				//SOLID BODY:1-100
				UF_LAYER_ask_category_tag("SOLID BODY", &category);
				if(category == NULL_TAG)
				{
					for(int i = 0; i < 256; i++)
					{
						if( i < 100 ) info.layer_mask[i] = 1;	//Change 100 to a, the the layer of SOLID BODY will be 0-a
						else info.layer_mask[i] = 0;
					}
					sprintf(info.name, NAME_SOLID_BODY);	//Name of the category, change "SOLID BODY" to something else
					sprintf(info.descr, DESCRIPTION_SOLID_BODY);	//The description of the category
					UF_LAYER_create_category(&info, &category);
				}else
				{
					for(int i = 0; i < 256; i++)
					{
						if( i < 100 ) layer_mask[i] = 1;	//Change 100 to a, the the layer of SOLID BODY will be 0-a
						else layer_mask[i] = 0;
					}
					UF_LAYER_edit_category_layer(category, layer_mask);
					UF_LAYER_edit_category_descr(category, DESCRIPTION_SOLID_BODY);
				}
				for( int i = 0; i < 100; i++ )	//Change 100 to a, set the layers active
				{
					UF_LAYER_set_status(i, UF_LAYER_ACTIVE_LAYER);
				}

				//Change the default layer of Datum
				//DATUM:155
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				UF_LAYER_ask_category_tag("DATUM", &category);
				if(category == NULL_TAG)
				{
					info.layer_mask[LAYER_DATUM-1] = 1;	
					sprintf(info.name, NAME_DATUM);	
					sprintf(info.descr, DESCRIPTION_DATUM);	
					UF_LAYER_create_category(&info, &category);
				}else
				{
					memset(layer_mask, 0, sizeof(layer_mask));
					layer_mask[LAYER_DATUM-1] =1;	
					UF_LAYER_edit_category_layer(category, layer_mask);	
					UF_LAYER_edit_category_descr(category,DESCRIPTION_DATUM);	
				}
				UF_LAYER_set_status(LAYER_DATUM, UF_LAYER_INACTIVE_LAYER);
			

				//Create the layer for sheet body
				//SHEET BODY:100-150
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				for(int i = 0; i < 256; i++)
				{
					if( i > 99 && i < 150 ) info.layer_mask[i] = 1;	
					else info.layer_mask[i] = 0;
				}
				sprintf(info.name, NAME_SHEET_BODY);	
				sprintf(info.descr, DESCRIPTION_SHEET_BODY);	
				UF_LAYER_create_category(&info, &category); 
				for( int i = 100; i < 150; i++ )	
				{
					UF_LAYER_set_status(i, UF_LAYER_ACTIVE_LAYER);
				}

				//Create the layer for routing objects
				//ROUTING OBJECT:156
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_ROUTING_OBJECT-1] =1;	
				sprintf(info.name, NAME_ROUTING_OBJECT);	
				sprintf(info.descr, DESCRIPTION_ROUTING_OBJECT);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_ROUTING_OBJECT, UF_LAYER_INACTIVE_LAYER);	

				//Create the layer for curve&points
				//CURVE and POINT:157
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_CURVE_POINT-1] =1;	
				sprintf(info.name, NAME_CURVE_POINT);	
				sprintf(info.descr, DESCRIPTION_CURVE_POINT);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_CURVE_POINT, UF_LAYER_INACTIVE_LAYER);	

				//Create the layer for sketch
				//SKETCH:158
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_SKETCH-1] =1;	
				sprintf(info.name, NAME_SKETCH);	
				sprintf(info.descr, DESCRIPTION_SKETCH);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_SKETCH, UF_LAYER_INACTIVE_LAYER);	

				//Create the layer for centerline
				//CENTERLINE:159
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_CENTERLINE-1] =1;	
				sprintf(info.name, NAME_CENTERLINE);	
				sprintf(info.descr, DESCRIPTION_CENTERLINE);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_CENTERLINE, UF_LAYER_ACTIVE_LAYER);	

				//Create the layer for section line
				//SECTION LINE:247
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_SECTION_LINE-1] =1;	
				sprintf(info.name, NAME_SECTION_LINE);	
				sprintf(info.descr, DESCRIPTION_SECTION_LINE);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_SECTION_LINE, UF_LAYER_ACTIVE_LAYER);	

				//Create the layer for balloon
				//BALLOON:248
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_BALLOON-1] =1;	
				sprintf(info.name, NAME_BALLOON);	
				sprintf(info.descr, DESCRIPTION_BALLOON);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_BALLOON, UF_LAYER_ACTIVE_LAYER);	

				//Create the layer for dimension
				//DIMENSION:249
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_DIMENSION-1] =1;	
				sprintf(info.name, NAME_DIMENSION);	
				sprintf(info.descr, DESCRIPTION_DIMENSION);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_DIMENSION, UF_LAYER_ACTIVE_LAYER);

				//Create the layer for ecav bubble
				//ECAV BUBBLE:250
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_ECAV_BUBBLE-1] =1;	
				sprintf(info.name, NAME_ECAV_BUBBLE);	
				sprintf(info.descr, DESCRIPTION_ECAV_BUBBLEN);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_ECAV_BUBBLE, UF_LAYER_ACTIVE_LAYER);	

				//Create the layer for note & label
				//NOTE and LABEL:251
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_NOTE_LABEL-1] =1;	
				sprintf(info.name, NAME_NOTE_LABEL);	
				sprintf(info.descr, DESCRIPTION_NOTE_LABEL);	
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_NOTE_LABEL, UF_LAYER_ACTIVE_LAYER);	

				//Create the layer for GD&T
				//GDT:252
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_GDT-1] =1;
				sprintf(info.name, NAME_GDT);	
				sprintf(info.descr, DESCRIPTION_GDT);	
				UF_LAYER_create_category(&info, &category);		
				UF_LAYER_set_status(LAYER_GDT, UF_LAYER_ACTIVE_LAYER);

				//Create the layer for welding symbol
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_WELDING_SYMBOL-1] =1;
				sprintf(info.name, NAME_WELDING_SYMBOL);
				sprintf(info.descr, DESCRIPTION_WELDING_SYMBOL);
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_WELDING_SYMBOL, UF_LAYER_ACTIVE_LAYER);

				//create the layer for CTQ
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_CTQ-1] =1;
				sprintf(info.name, NAME_CTQ);
				sprintf(info.descr, DESCRIPTION_CTQ);
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_CTQ, UF_LAYER_ACTIVE_LAYER);

				//create the layer for formate
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_FORMATE-1] =1;
				sprintf(info.name, NAME_FORMATE);
				sprintf(info.descr, DESCRIPTION_FORMATE);
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_FORMATE, UF_LAYER_ACTIVE_LAYER);

				//create the layer for non-assocaited dimension
				memset(info.name, 0, sizeof(info.name));
				memset(info.descr, 0, sizeof(info.descr));
				memset(info.layer_mask, 0, sizeof(info.layer_mask));
				info.layer_mask[LAYER_NON_ASSOCIATED_DIMENSION-1] =1;
				sprintf(info.name, NAME_NON_ASSOCIATED_DIMENSION);
				sprintf(info.descr, DESCRIPTION_NON_ASSOCIATED_DIMENSION);
				UF_LAYER_create_category(&info, &category); 
				UF_LAYER_set_status(LAYER_NON_ASSOCIATED_DIMENSION, UF_LAYER_ACTIVE_LAYER);

				uc1601("Operation succeed",1);
				classification_done = true;
			}
        }
        else if(block == button01)
        {
			classification_done = true;
			tag_t category;
			UF_LAYER_ask_category_tag("SOLID BODY", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("SHEET BODY", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("DATUM", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("ROUTING OBJECT", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("CURVE and POINT", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("SKETCH", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("CENTERLINE", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("SECTION LINE", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("BALLOON", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("DIMENSION", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("ECAV BUBBLE", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("NOTE and LABEL", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("GDT", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("WELDING SYMBOL", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("CTQ", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("FORMATE", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}
			UF_LAYER_ask_category_tag("NON-ASSOCIATED DIMENSION", &category);
			if(category == NULL_TAG){
				classification_done = false;
			}


			if(classification_done)
			{
				Session *mySession = Session::GetSession();
				Part *workPart(mySession->Parts()->Work());
				Part *displayPart(mySession->Parts()->Display());
				BasePart *basePart(mySession->Parts()->BaseWork());
				displayPart->ModelingViews()->WorkView()->Fit();

				tag_t prt = UF_PART_ask_display_part();
				tag_t Next_tag = NULL_TAG;
				int bodytype;
				int obj_type, obj_subtype;

				for(int i =0; i<256; i++)
				{
					while(1)
					{
						UF_LAYER_cycle_by_layer(i+1, &Next_tag);
						if(Next_tag == NULL_TAG) break;

						UF_OBJ_ask_type_and_subtype(Next_tag, &obj_type, &obj_subtype);

						//solid body and sheet body
						if(obj_type == UF_solid_type)
						{
							UF_MODL_ask_body_type(Next_tag, &bodytype);
							if(bodytype == UF_MODL_SOLID_BODY)
							{
								if( i < 100 )
								{
									//do nothing
								}
								else UF_OBJ_set_layer(Next_tag,LAYER_SOLID_BODY);
							}
							if(bodytype == UF_MODL_SHEET_BODY)
							{
								if( i > 99 && i < 150 )
								{
									//do nothing
								}
								else UF_OBJ_set_layer(Next_tag,LAYER_SHEET_BODY);
							}
						}

						//sketch
						if(obj_type == UF_sketch_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_SKETCH);
						}

						//dimension
						if(obj_type == UF_dimension_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_DIMENSION);
						}

						//point & curve
						if(obj_type == UF_point_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_CURVE_POINT);
						}
						if(obj_type == UF_line_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_CURVE_POINT);
						}
						if(obj_type == UF_circle_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_CURVE_POINT);
						}
						if(obj_type == UF_spline_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_CURVE_POINT);
						}

						//datum
						if(obj_type == UF_datum_plane_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_DATUM);
						}
						if(obj_type == UF_datum_axis_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_DATUM);
						}

						//Routing objects
						if(obj_type == UF_route_control_point_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_port_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_stock_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_route_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_segment_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_connection_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_corner_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}
						if(obj_type == UF_route_cross_section_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_ROUTING_OBJECT);
						}

						//Note and label
						if(obj_type == UF_note_type)
						{
							UF_OBJ_set_layer(Next_tag,LAYER_NOTE_LABEL);
						}
					}
				}

				//Routing objects
				NXOpen::Routing::SplineSegmentCollection::iterator it_routing_spline;
				for(it_routing_spline = workPart->SegmentManager()->SplineSegments()->begin() ; it_routing_spline != workPart->SegmentManager()->SplineSegments()->end() ; it_routing_spline ++ )
				{
					Routing::SplineSegment* routing_spline = (Routing::SplineSegment*) *it_routing_spline;
					std::vector<DisplayableObject *> routingsplineArray(1);
					routingsplineArray[0] = routing_spline;
					workPart->Layers()->MoveDisplayableObjects(LAYER_ROUTING_OBJECT,routingsplineArray);
				}

				NXOpen::Routing::LineSegmentCollection::iterator it_routing_line;
				for(it_routing_line = workPart->SegmentManager()->LineSegments()->begin() ; it_routing_line != workPart->SegmentManager()->LineSegments()->end() ; it_routing_line ++ )
				{
					Routing::LineSegment* routing_line = (Routing::LineSegment*) *it_routing_line;
					std::vector<DisplayableObject *> routinglineArray(1);
					routinglineArray[0] = routing_line;
					workPart->Layers()->MoveDisplayableObjects(LAYER_ROUTING_OBJECT,routinglineArray);
				}

				NXOpen::Routing::ArcSegmentCollection::iterator it_routing_arc;
				for(it_routing_arc = workPart->SegmentManager()->ArcSegments()->begin() ; it_routing_arc != workPart->SegmentManager()->ArcSegments()->end() ; it_routing_arc ++ )
				{
					Routing::ArcSegment* routing_arc = (Routing::ArcSegment*) *it_routing_arc;
					std::vector<DisplayableObject *> routingarcArray(1);
					routingarcArray[0] = routing_arc;
					workPart->Layers()->MoveDisplayableObjects(LAYER_ROUTING_OBJECT,routingarcArray);
				}

				NXOpen::Routing::AnchorCollection::iterator it_routing_anchor;
				for(it_routing_anchor = workPart->RouteManager()->Anchors()->begin(); it_routing_anchor != workPart->RouteManager()->Anchors()->end() ; it_routing_anchor ++ )
				{
					Routing::Anchor* routing_anchor = (Routing::Anchor*) *it_routing_anchor;
					std::vector<DisplayableObject *> routinganchorArray(1);
					routinganchorArray[0] = routing_anchor;
					workPart->Layers()->MoveDisplayableObjects(LAYER_ROUTING_OBJECT,routinganchorArray);
				}

				//Note
				NXOpen::Annotations::NoteCollection::iterator it_note;
				for(it_note = workPart->Notes()->begin() ; it_note != workPart->Notes()->end() ; it_note ++ )				
				{
					Annotations::PmiNote* note = (Annotations::PmiNote*) *it_note;
					std::vector<DisplayableObject *> noteArray(1);
					noteArray[0] = note;
					workPart->Layers()->MoveDisplayableObjects(LAYER_NOTE_LABEL, noteArray);
				}

				//Label
				NXOpen::Annotations::LabelCollection::iterator it_label;
				for(it_label = workPart->Labels()->begin() ; it_label != workPart->Labels()->end() ; it_label ++ )				
				{
					Annotations::Label* label = (Annotations::Label*) *it_label;
					std::vector<DisplayableObject *> labelArray(1);
					labelArray[0] = label;
					workPart->Layers()->MoveDisplayableObjects(LAYER_NOTE_LABEL, labelArray);
				}

				//GDT
				NXOpen::Annotations::GdtCollection::iterator it_gdt;
				for(it_gdt = workPart->Gdts()->begin() ; it_gdt != workPart->Gdts()->end() ; it_gdt ++ )				
				{
					Annotations::Gdt* gdt = (Annotations::Gdt*) *it_gdt;
					std::vector<DisplayableObject *> gdtArray(1);
					gdtArray[0] = gdt;
					workPart->Layers()->MoveDisplayableObjects(LAYER_GDT, gdtArray);
				}

				//GDT datum
				NXOpen::Annotations::GdtDatumCollection::iterator it_gdt_datum;
				for(it_gdt_datum = workPart->Annotations()->Datums()->begin() ; it_gdt_datum != workPart->Annotations()->Datums()->end() ; it_gdt_datum ++ )				
				{
					Annotations::Gdt* gdt_datum = (Annotations::Gdt*) *it_gdt_datum;
					std::vector<DisplayableObject *> gdtdatumArray(1);
					gdtdatumArray[0] = gdt_datum;
					workPart->Layers()->MoveDisplayableObjects(LAYER_GDT, gdtdatumArray);
				}

				NXOpen::Annotations::DatumTargetCollection::iterator it_datum_target;
				for(it_datum_target = workPart->Annotations()->DatumTargets()->begin() ; it_datum_target != workPart->Annotations()->DatumTargets()->end() ; it_datum_target ++ )				
				{
					Annotations::DatumTarget* datum_target = (Annotations::DatumTarget*) *it_datum_target;
					std::vector<DisplayableObject *> datumtargetArray(1);
					datumtargetArray[0] = datum_target;
					workPart->Layers()->MoveDisplayableObjects(LAYER_GDT, datumtargetArray);
				}

				//Centerline 
				NXOpen::Annotations::CenterlineCollection::iterator it_centerline;
				for(it_centerline = workPart->Annotations()->Centerlines()->begin() ; it_centerline != workPart->Annotations()->Centerlines()->end() ; it_centerline ++ )				
				{
					Annotations::PmiCenterline3d* centerline = (Annotations::PmiCenterline3d*) *it_centerline;
					std::vector<DisplayableObject *> centerlineArray(1);
					centerlineArray[0] = centerline;
					workPart->Layers()->MoveDisplayableObjects(LAYER_CENTERLINE, centerlineArray);
				}

				//Welding
				NXOpen::Annotations::WeldCollection::iterator it_weld;
				for(it_weld = workPart->Annotations()->Welds()->begin() ; it_weld != workPart->Annotations()->Welds()->end() ; it_weld ++ )				
				{
					Annotations::Weld* welding = (Annotations::Weld*) *it_weld;
					std::vector<DisplayableObject *> weldArray(1);
					weldArray[0] = welding;
					workPart->Layers()->MoveDisplayableObjects(LAYER_WELDING_SYMBOL, weldArray);
				}
				
				//Cutting surface
				/*std::vector<DisplayableObject*> visObjects = workPart->Views()->WorkView()->AskVisibleObjects();
				for(std::vector<DisplayableObject*>::iterator it=visObjects.begin();it!=visObjects.end();it++)
				{
					Annotations::CuttingPlaneSymbol* cuttingplane_symbol = (Annotations::CuttingPlaneSymbol*) *it;
					std::vector<DisplayableObject *> cuttingplanesymbolArray(1);
					cuttingplanesymbolArray[0] = cuttingplane_symbol;
					workPart->Layers()->MoveDisplayableObjects(LAYER_SECTION_LINE, cuttingplanesymbolArray);
				}*/
				//NXOpen::Annotations::PmiLightweightSectionCollection::iterator it_section;
				//for(it_section =  workPart->PmiManager()->PmiLightweightSections()->begin() ; it_section != workPart->PmiManager()->PmiLightweightSections()->end() ; it_section ++ )				
				//{
				//	Annotations::LightweightSection* section = dynamic_cast<Annotations::LightweightSection*>(*it_section);
				//	if(section != NULL)
				//	{
				//		Annotations::LightweightSectionBuilder* sectionplane_builder;
				//		sectionplane_builder =  workPart->PmiManager()->PmiLightweightSections()->CreateLightweightSectionBuilder(section);
				//		//sectionplane_builder->CuttingPlaneSymbol()->SetDisplayCuttingPlaneSymbol(false);
				//		//NXObject *cuttingplane_object;
				//		//cuttingplane_object = sectionplane_builder->;
				//		//sectionplane_builder->Destroy();
				//		
				//	}
				//	
				//}
						//dynamic_cast<DisplayableObject *>(NXObject1)->SetLayer(247);
						/*Annotations::CuttingPlaneSymbol *cuttingplane = dynamic_cast<Annotations::CuttingPlaneSymbol*>(NXObject1);
						if(cuttingplane != NULL){
							std::vector<DisplayableObject *> sectionplaneArray(1);
							sectionplaneArray[0] = cuttingplane;
							workPart->Layers()->MoveDisplayableObjects(247, sectionplaneArray);
						}*/
					//}
				//}

				//PMI attribute
				NXOpen::Annotations::PmiAttributeCollection::iterator it_pmi_attr;
				for(it_pmi_attr = workPart->PmiManager()->PmiAttributes()->begin() ; it_pmi_attr != workPart->PmiManager()->PmiAttributes()->end() ; it_pmi_attr ++ )				
				{
					Annotations::BalloonNote* balloonnote = dynamic_cast<Annotations::BalloonNote*>(*it_pmi_attr);
					Annotations::SurfaceFinish* surfacefinish = dynamic_cast<Annotations::SurfaceFinish*>(*it_pmi_attr);
					Annotations::CoordinateNote* coordinatenote = dynamic_cast<Annotations::CoordinateNote*>(*it_pmi_attr);
					//Balloonnote
					if(balloonnote != NULL)
					{
						std::vector<DisplayableObject *> balloonnoteArray(1);
						balloonnoteArray[0] = balloonnote;
						workPart->Layers()->MoveDisplayableObjects(LAYER_BALLOON, balloonnoteArray);
					}
					//Surface finish
					if(surfacefinish != NULL)
					{
						std::vector<DisplayableObject *> surfacefinishArray(1);
						surfacefinishArray[0] = surfacefinish;
						workPart->Layers()->MoveDisplayableObjects(LAYER_GDT, surfacefinishArray);
					}
					//Coordinatenote
					if(coordinatenote != NULL)
					{
						std::vector<DisplayableObject *> coordinatenoteArray(1);
						coordinatenoteArray[0] = coordinatenote;
						workPart->Layers()->MoveDisplayableObjects(LAYER_DIMENSION, coordinatenoteArray);
					}
				}

				//Feature iterator to find csys
				NXOpen::Features::FeatureCollection::iterator it_feature;
				for(it_feature = workPart->Features()->begin() ; it_feature != workPart->Features()->end() ; it_feature ++ )				
				{
					Features::DatumCsys* csys = dynamic_cast<Features::DatumCsys*>(*it_feature);
					//csys
					if(csys != NULL)
					{
						std::vector<NXObject *> theEntities = csys->GetEntities();
						for (int i=0; i < theEntities.size(); i++)
						{
							Point *point(dynamic_cast<Point*>(theEntities[i]));
							CartesianCoordinateSystem *csys_coodinate(dynamic_cast<CartesianCoordinateSystem*>(theEntities[i]));	
							if(csys_coodinate != NULL){
								std::vector<DisplayableObject *> csysArray(1);
								csysArray[0] = csys_coodinate;
								workPart->Layers()->MoveDisplayableObjects(LAYER_DATUM, csysArray);
							}
							if(point != NULL){
								std::vector<DisplayableObject *> pointArray(1);
								pointArray[0] = point;
								workPart->Layers()->MoveDisplayableObjects(LAYER_DATUM, pointArray);
							}
						}
					}
				}

				//------Delete category without objects-------
				NXOpen::Layer::CategoryCollection::iterator it_category;
				for(it_category = basePart->LayerCategories()->begin() ; it_category != basePart->LayerCategories()->end() ; it_category ++ )				
				{
					Layer::Category* category = dynamic_cast<Layer::Category*>(*it_category);
					if(category != NULL)
					{
						bool delete_category = true;
						std::vector<int> layer_number = category->GetMemberLayers();
						for (int i=0; i < layer_number.size(); i++)
						{
							while(1)
							{
								UF_LAYER_cycle_by_layer(layer_number[i], &Next_tag);
								if(Next_tag == NULL_TAG){
									break;
								}else{
									delete_category = false;
								}
							}
						}
						if(delete_category)
						{
							int nErrs1;
							nErrs1 = theSession->UpdateManager()->AddToDeleteList(category);
						}
					}
				}

				uc1601("Finished!",1);
			}
			else
			{
				uc1601("Please create category first!",1);
			}
        }
		UF_terminate();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int Layer_manager::ok_cb()
{
    int errorCode = 0;
    try
    {
        errorCode = apply_cb();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

//------------------------------------------------------------------------------
//Callback Name: enableOKButton_cb
//This callback allows the dialog to enable/disable the OK and Apply button.
//------------------------------------------------------------------------------
bool Layer_manager::enableOKButton_cb()
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        Layer_manager::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return true;
}

void Layer_manager::Splite(string input_str, char* symbol, vector<string>& output_str)
{
	const int len = strlen(symbol);
	size_t index = 0;  
    size_t pos = input_str.find(symbol,index); 
	while(pos != string::npos)  
    {  
        string ss = input_str.substr(index,pos-index);  
		if(!ss.empty())
		{
			output_str.push_back(ss); 
		}
        index = pos + len;  
        pos = input_str.find(symbol,index);  
    }
	if((index+1) < input_str.length())  
    {  
        string ss = input_str.substr(index,input_str.length() - index);  
		if(!ss.empty())
		{
			output_str.push_back(ss); 
		}
    }  
	return;
}

void Layer_manager::TcharToChar(const TCHAR * tchar, char * _char)
{
    int iLength;
    //获取字节长度   
    iLength = WideCharToMultiByte(CP_ACP, 0, tchar, -1, NULL, 0, NULL, NULL);
    //将tchar值赋给_char    
    WideCharToMultiByte(CP_ACP, 0, tchar, -1, _char, iLength, NULL, NULL);
}

//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* Layer_manager::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}
